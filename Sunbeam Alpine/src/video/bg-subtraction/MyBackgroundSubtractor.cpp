//
// Created by filip on 07.02.16.
//
#include "opencv2/imgcodecs.hpp"
#include "opencv2/imgproc.hpp"
#include "opencv2/videoio.hpp"
#include <video/bg-subtraction/MyBackgroundSubtractor.hpp>
#include <opencv2/highgui.hpp>
#include <opencv2/video.hpp>
#include <iostream>
#include <math.h>

using namespace cv;
using namespace std;

MyBackgroundSubtractor::MyBackgroundSubtractor()
{
	pMOG2 = createBackgroundSubtractorMOG2();
	//_mc = MissionControl();
}

void MyBackgroundSubtractor::help()
{
	cout
		<< "--------------------------------------------------------------------------" << endl
		<< "This program shows how to use background subtraction methods provided by " << endl
		<< " OpenCV. You can process both videos (-vid) and images (-img)." << endl
		<< endl
		<< "Usage:" << endl
		<< "./bs {-vid <video filename>|-img <image filename>}" << endl
		<< "for example: ./bs -vid video.avi" << endl
		<< "or: ./bs -img /data/images/1.png" << endl
		<< "--------------------------------------------------------------------------" << endl
		<< endl;
}

Mat MyBackgroundSubtractor::subtractBackground(const Mat& frame)
{

	Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method

	Mat erodedMask;
	Mat reversed;
	//update the background model
	static int old_learning_rate = 5;
	int learning_rate = 2;
	_mc.Add("learning_rate", learning_rate, 8);
	if (old_learning_rate != learning_rate)
	{
		pMOG2->clear();
		old_learning_rate = learning_rate;
	}
	pMOG2->apply(frame, fgMaskMOG2, pow(10, -learning_rate));
	//    imshow("fgMaskMOG2", fgMaskMOG2);
	int erosion_size = 1;
	_mc.Add("erosion_size", erosion_size, 15);
	Mat element = getStructuringElement(cv::MORPH_CROSS,
		cv::Size(2 * erosion_size + 1, 2 * erosion_size + 1),
		cv::Point(erosion_size, erosion_size));

	cv::erode(fgMaskMOG2, erodedMask, element);
	//    imshow("fgMaskMOG2 ERODED", erodedMask);
	fillHolesInBinaryMask(erodedMask);
	//    imshow("fgMaskMOG2 ERODED Filled", erodedMask);
	frame.copyTo(frame, erodedMask);
	//    bitwise_not(erodedMask, reversed);
	//    destroyAllWindows();
	//
	return erodedMask;
}


void MyBackgroundSubtractor::fillHolesInBinaryMask(cv::Mat &mat)
{
	int morph_size = 3;
	_mc.Add("morph_size FHBM", morph_size, 15);
	//    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE,(3,3))
	//    res = cv2.morphologyEx(gray,cv2.MORPH_OPEN,kernel)
	Mat element = getStructuringElement(0, Size(2 * morph_size + 1, 2 * morph_size + 1), Point(morph_size, morph_size));

	/// Apply the specified morphology operation
	morphologyEx(mat, mat, MORPH_CLOSE, element);
}